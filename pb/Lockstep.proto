syntax = "proto3";
package m2.pb;

import "m2g_Lockstep.proto";

message LockstepPeer {
  fixed32 ip = 1; // Network order
  fixed32 port = 2; // Network order
}
message LockstepPeerDetails {
  // Index of the receiver in the peer details array
  int32 receiver_index = 1;
  repeated LockstepPeer peers = 2;
}

message LockstepPlayerInputs {
  fixed32 timecode = 1;
  repeated m2g.pb.LockstepPlayerInput player_inputs = 2;
}

// Each LockstepMessage has a different SequenceNo starting from 1.
message LockstepMessage {
  oneof type {
    LockstepPeerDetails peer_details = 2;
    // A message type sent to the server from clients. It is used to signal readiness to the server.
    bool set_ready_state = 3;
    // A message type sent to the clients from the server. When all clients are ready and the host starts the game, this
    // message is used to share the game init parameters with the clients, effectively starting the game for them.
    m2g.pb.LockstepGameInitParams freeze_lobby_with_init_params = 4;
    // A message type send to the everyone by the clients. Once the game begins, this message is sent to every other peer
    // periodically, even if the player hasn't taken any action.
    LockstepPlayerInputs player_inputs = 5;
  }
}

// Each LockstepSmallMessage has a different OrderNo starting from 1. A small message contains either a full
// LockstepMessage if it is small enough. Or, a part of a LockstepMessage is contained for reconstruction later.
message LockstepSmallMessage {
  // Order number of this small message
  fixed32 order_no = 1;

  // If complete_message is set, contains the SequenceNo of the full LockstepMessage. If message_part is set, contains
  // the SequenceNo of the message that is partially contained.
  fixed32 message_sequence_no = 2;

  oneof Type {
    LockstepMessage complete_message = 3;
    bytes message_part = 4;
  }

  // If message_part is set, contains the total size of the LockstepMessage once reconstructed.
  fixed32 reconstructed_message_size = 5;
}

// This message is serialized to the body of a UDP packet without any headers or footers.
message LockstepUdpPacket {
  // UDP is connectionless, each packet needs to prove that it is ours.
  sfixed32 game_hash = 1;

  // Highest 8 bits: Major version. Middle 16 bits: Minor version. Lowest 8 bits: Patch version.
  fixed32 version = 2;

  // Order number of the most recently received LockstepSmallMessage by the sender of this packet.
  fixed32 most_recent_ack = 3;

  // Each bit, starting from the least significant one, represents the delivery status of a LockstepSmallMessage from
  // the point of the sender of this packet. Each set bit represents a message that is received. Least significant bit
  // corresponds to the message before most_recent_ack.
  fixed32 ack_history_bits = 4;

  // Order number of the oldest gap in the received LockstepSmallMessages by the sender of this packet. This field is
  // particularly useful if an old message that doesn't fit into ack_history_bits is still missing.
  fixed32 oldest_nack = 5;

  // Messages doesn't need to be incremental, but it needs to be in order.
  repeated LockstepSmallMessage small_messages = 6;
}

message LockstepPlayerInputHashHelper {
  int32 prev_hash = 1;
  fixed32 ip = 2; // Network order
  fixed32 port = 3; // Network order
  LockstepPlayerInputs player_inputs = 4;
}
